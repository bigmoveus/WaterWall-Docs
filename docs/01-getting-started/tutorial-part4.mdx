---
sidebar_position: 4
---

# آموزش بخش چهارم 📚

## دسته‌بندی Node ها 🔗

در واتروال ما Node ها را به **۳ گروه** تقسیم می‌کنیم:

### 📊 **دسته اول - Node های لایه ۴**
Node هایی هستند که با کانکشن کار می‌کنند. این نود ها لایه ۴ هستند (لایه ۷ هم می‌شه گفت که همون لایه اپلیکیشن هست)

**✅ مزایا:**
- این نود ها برای اجرا نیازی به دسترسی root ندارند
- کار کردن با آن‌ها ساده‌تر است

**📋 مثال‌های این دسته:**
- `TcpConnector/Listener`
- `UdpConnector/Listener`
- `HalfDuplexClient/Server`
- `ReverseClient/Server`

⚠️ **نکته مهم:** این نود ها نباید با نود های لایه ۳ در یک زنجیر قرار بگیرند، چون نود های لایه ۳ با پکت کار می‌کنند نه صرفاً روی کانکشن.

### 🌐 **دسته دوم - Node های لایه ۳**
Node هایی هستند که به لایه ۳ تعلق دارند و پکت‌های خام لایه IP را منتقل می‌کنند.

**📋 مثال‌های این دسته:**
- `TunDevice`
- `RawDevice`
- `IpOverreider`
- `IpManipulator`

⚠️ **نکته مهم:** این‌ها نباید با نود های لایه ۴ قاطی شوند یا زنجیر شوند.

### 🔄 **دسته سوم - Node های تبدیل‌گر**
Node هایی هستند که اگر داخل زنجیر بیایند، باعث می‌شوند که بتوانید نود های لایه ۳ و ۴ را همزمان در آن زنجیر به هم متصل کنید.

#### **مثال اول:** `PacketToConnection` 🔌
این نود برای پیاده کردن چیزی مثل TunMode روی کلاینت‌ها استفاده می‌شود و کاربردش تخصصی است.

**🔄 نحوه کار:**
- قبل از آن باید نود های لایه ۳ باشند
- بعد از آن نود های لایه ۴ قرار می‌گیرند
- همانطور که از اسمش پیداست، پکت هایی که از چپ به راست وارد می‌شوند را پردازش می‌کند
- متوجه می‌شود که سیستم عامل به کجا می‌خواهد کانکشن بزند
- بعد خودش همان کانکشن را ایجاد می‌کند داخل واتروال

#### **مثال دوم:** `PacketAsData` و `DataAsPacket` 📦
دو node زیر نیز به این دسته تعلق دارند:

**🔄 `DataAsPacket`:**
- وقتی پکت‌ها از سمت چپ به راست حرکت می‌کنند، آن‌ها را در یک کانکشن قرار می‌دهد
- وقتی داده‌ها از راست به چپ حرکت می‌کنند، انتظار دارد که آن‌ها پکت باشند
- پکت‌ها را به سمت چپ منتقل می‌کند

- سمت راست این node باید لایه ۳ باشه و سمت چپش لایه ۳


**🔄 `PacketAsData`:**
- دقیقاً همین کار را انجام می‌دهد فقط جهتش برعکس است
- سمت راست این node باید لایه ۴ باشه و سمت چپش لایه ۳

**🎯 کاربرد:** این نود ها برای زمانی هستند که شما چیزی مثل OpenVPN یا WireGuard می‌خواهید درست کنید.

---

## مثال عملی: OpenVPN 🔐

OpenVPN پکت‌ها را مستقیماً از یک tun device دریافت می‌کند و سپس آن‌ها را از یک کانکشن که با TLS رمز شده عبور می‌دهد. این‌طوری یک سناریو ساده و در عین حال قدرتمند ساخته می‌شود.

### 📱 **سمت کلاینت:** 

```mermaid
flowchart LR;
    TunDevice --> PacketAsData --> SSLClient --> TcpConnector
```

### 🖥️ **سمت سرور VPN:**

```mermaid
flowchart LR;
    TcpListener --> SSLServer --> DataAsPacket --> TunDevice
```

**💡 نکته:** حتی نیازی به تغییر IP ها هم ندارد. فقط یک کامند تولید NAT از دیتای TunDevice روی VPN Server اجرا می‌شود تا پکت‌ها به بیرون هدایت شوند.

همچنین یک کامند سمت کلاینت اجرا می‌شود که از سیستم عامل می‌خواهد تمام پکت‌ها را به TunDevice هدایت کند.


⚠️ **نکته درمورد OpenVPN:** الان یک node هنوز در زنجیر نیست که کامل شود و بتوانید پیاده‌اش کنید. آن هم نود احراز هویت‌کننده پروتکل OpenVPN است. این هنوز پیاده‌سازی نشده (الان که دارم این را می‌نویسم)، ولی WireGuard کامل است.

---

## مثال عملی: WireGuard 🚀

اگر شما با WireGuard آشنا باشید، آن نیز خیلی شبیه OpenVPN است، منتها چند نقطه قوت دارد که آن را به یکی از بهترین پروتکل‌ها در شرایط ایده‌آل (بدون فیلترینگ) تبدیل می‌کند:

### 🔥 **مزایای WireGuard:**
1. **📡 UDP:** از UDP برای انتقال دیتا استفاده می‌کند و برای همین پکت‌ها به صورت یکپارچه منتقل می‌شوند (البته با MTU کمتر)

2. **🔐 الگوریتم رمزنگاری مدرن:** بر مبنای رمزنگاری مدرن و مینیمال با محوریت `Curve25519` و `ChaCha20-Poly1305` ساخته شده است
   - سبک و CPU-friendly است
   - هندشیک کمتری نیاز دارد
   - امن است


### 📊 **ساختار WireGuard با واتروال:**

#### **سمت کلاینت:** 

```mermaid
flowchart LR;
    TunDevice --> PacketAsData --> WireGuardDevice --> UdpStateLessSocket
```

#### **سمت سرور VPN:**

```mermaid
flowchart LR;
    TunDevice --> PacketAsData --> WireGuardDevice --> UdpStateLessSocket
```

🤔 **سوال:** شاید برایتان این ساختار یکمی عجیب باشد، بخصوص اینکه سرور ایران شبیه سرور خارج شده است. باید بگویم WireGuard کلاً این‌طوری است!

**🔄 جهت برعکس:** اگر نود ها را برعکس بچینید هم همین سناریو درمی‌آید و درست کار می‌کند:

#### **سمت کلاینت (برعکس):**

```mermaid
flowchart LR;
    UdpStateLessSocket --> WireGuardDevice --> DataAsPacket --> TunDevice
```

#### **سمت سرور VPN (برعکس):**

```mermaid
flowchart LR;
    UdpStateLessSocket --> WireGuardDevice --> DataAsPacket --> TunDevice
```

### 🔍 **چرا UdpStateLessSocket؟**

علت اینکه از `UdpListener` / `UdpConnector` استفاده نشده این است که WireGuard ساختارش این‌گونه طراحی شده که از همان socket و پورتی که با آن پکت ارسال می‌کند، پکت هم دریافت می‌کند.

**❌ مشکل نود های قبلی:**
- `UdpListener` فقط گوش‌دهنده بود و نمی‌توانست شروع‌کننده باشد به یک peer
- `UdpConnector` فقط ارسال‌کننده بود و نمی‌توانست وقتی یک peer قبل از آن پکت داده، آن را پردازش کند

**✅ راه حل:** یک node جدید ساخته شد که از یک پورت هم بفرستد و هم گوش کند به اسم `UdpStateLessSocket`

📝 **نکته:** کامندهایی که باید تنظیم شوند دقیقاً مثل OpenVPN است و نکته دیگری ندارد.

### 📚 **منابع بیشتر:**

من ترجیح می‌دهم از اینجا به بعد فایل JSON برایتان نگذارم. به نظرم همان دیاگرام‌ها برای فهمیدن اینکه چطور باید بسازیدشان کافی است.

در صفحه **Examples** می‌توانید کامل‌تر درمورد ساختن سناریوهای WireGuard یا OpenVPN اطلاعات کسب کنید.


---

## تغییر و بازی با پکت‌ها 🎮

### 🚇 **سناریو Packet Tunnel**

اینجا می‌خواهم درمورد یک سناریو تونل توضیح دهم که اسمش **Packet Tunnel** است.

**📋 سناریو:** شما بین ۲ سرور (ایران و خارج) یک تونل برقرار می‌کنید که در این بین پکت‌ها به شکل غیرعادی و تغییر یافته منتقل خواهند شد.

### 🛠️ **کارهایی که می‌توان کرد:**

1. **🔀 جابه‌جا کردن بیت‌های TCP**
2. **🆔 تغییر identifier در هدر IP** تا به صورت جعلی به یکی از پروتکل‌های زیر تبدیل شود:
   - [📋 List Of IP Layer Protocols](https://en.wikipedia.org/wiki/List_of_IP_protocol_numbers)
3. **🧩 تکه‌تکه کردن پکت‌ها** (این حالت نیازی حتی به اجرای واتروال در سرور خارج ندارد)
4. **🔗 ترکیب این حالت‌ها**

**💡 نکته:** شما می‌توانید ۲ یا چند نود از نوع `IpManipulator` به هم زنجیر کنید و در هر کدام یک تغییر به پکت لایه IP بدهید. ولی روی یک Node فقط می‌شود یک ترفند روی پکت اجرا کرد، نه بیشتر.

### 📖 **مثال آموزشی: تغییر Identifier**

چیزی که من برای آموزش در نظر گرفتم، حالت ساده **تغییر identifier** است:

#### **🇮🇷 سرور ایران:**


```mermaid
flowchart LR;
    TunDevice["TunDevice<br/>10.10.0.1/24"] --> IPO1[IpOverreider] --> IPO2[IpOverreider] --> IpManipulator --> IPO3[IpOverreider] --> IPO4[IpOverreider] --> RawSocket
    
    TcpListener["TcpListener<br/>443"] --> TcpConnector["TcpConnector<br/>10.10.0.2:443"]
```

#### **🌍 سرور خارج:**

```mermaid
flowchart LR;
    RawSocket --> IPO1[IpOverreider] --> IPO2[IpOverreider] --> IpManipulator --> IPO3[IpOverreider] --> IPO4[IpOverreider] --> TunDevice["TunDevice<br/>10.10.0.1/24"]
```

### 🤔 **سوال: چرا این‌همه IpOverreider؟**

اولین سوال که برایتان پیش می‌آید این است که این همه node از نوع `IpOverreider` برای چی هستند؟

در سرور ایران توضیح می‌دهم (برای سرور خارج هم علتش همین است):

### 🔒 **مشکل امنیتی دیتاسنتر:**
اگر شما یک پکت به بیرون از سرور ارسال کنید که IP مبدایش IP خود سرور نباشد، پکت drop می‌شود توسط دیتاسنتر به خاطر جلوگیری از DDoS.

### 🎯 **وظیفه هر IpOverreider:**

#### **📤 نودهای UP (چپ به راست):**
1. **نود اول:** IP مبدا پکتی که از tun device گرفته را IP خود سرور قرار می‌دهد
2. **نود دوم:** IP مقصد را برابر با IP سرور خارج قرار می‌دهد (چون پکت‌ها IP مقصدشان وقتی دریافت می‌شوند `10.10.0.2` هستند)

#### **📥 نودهای DOWN (راست به چپ):**
در تنظیمات ۲ نود دیگر، `direction = down` تنظیم شده است. این یعنی این ۲ نود فقط پکت هایی را کار دارند که از راست به چپ می‌آیند.

**🔄 تغییرات مورد نیاز:**
- این پکت‌ها دقیقاً مشکل IP دارند
- IP مبدا: IP سرور خارج ← باید بشود `10.10.0.2`
- IP مقصد: IP سرور ایران ← باید بشود IP خود tun device که `10.10.0.1` است

**💡 هدف:** ما داریم tun device را کاملاً شبیه‌سازی می‌کنیم به یک دستگاهی که به صورت جادویی ارتباطی با دنیای بیرون برقرار می‌کند!

### ⚙️ **نود IpManipulator:**

ما به این نود می‌گوییم که باید **تغییر identifier** انجام دهد. این کار با تنظیماتش انجام می‌شود.

**🔄 protoswap-tcp:** یعنی هر پکتی که از نوع TCP بود را تغییر به آن عددی که گفته شده، و در پکت‌های برگشتی هم هر پکتی از آن عدد بود تغییر می‌کند به TCP.

**🔄 UDP:** شما می‌توانید اگر خواستید UDP هم تغییر دهید (مثلاً WireGuard را تونل کنید)، ولی باید یک نود `IpManipulator` دیگر به زنجیر اضافه کنید با عدد دیگری که با آن قبلی که برای TCP بود یکی نباشد. از protoswap-udp برای اینکار استفاده کنید.
### 🌐 **نود RawSocket:**

این نود هم می‌تواند دریافت و هم ارسال کند. برای همین در این سناریو هم اگر کل زنجیر را برعکس بچینید، درست کار می‌کند.

**🔧 نحوه کار:**
- برای ارسال: از یک raw socket استفاده می‌کند
- برای دریافت: از فایروال کمک می‌گیرد تا پکت‌های دریافتی به هیچ وجه دست سیستم عامل نرسند

**⚠️ چرا مهم است؟** در غیر این صورت سیستم عامل خود (مثلاً با TCP-reset) پاسخ می‌داد و نمی‌شد با همان socket دریافت کرد.

**💻 ویندوز:** در سیستم عامل ویندوز همین کار با استفاده از driver انجام می‌شود.

### 🎉 **نتیجه:**

پس از برقراری تونل در سرور ایران، IP `10.10.0.2` را می‌توان IP خارج فرض کرد که ارتباط با آن از فیلترینگ عبور کرده و حتی می‌شود ping گرفت! 🏓

**🚀 پورت فوروارد:** ما در سرور ایران پورت ۴۴۳ هم به این IP فوروارد کردیم، ولی شما می‌توانید:
- از iptables برای پورت فوروارد استفاده کنید
- یا اگر پنل روی سرور ایران نصب است، یک تونل outbound برقرار کنید

**🌍 سرور خارج:** IP `10.10.0.2` انگار شده IP سرور ایران و می‌توانید با آن ارتباط داشته باشید.

---

## 📄 **فایل JSON**

من فایل JSON این روش را برایتان همینجا قرار خواهم داد. 